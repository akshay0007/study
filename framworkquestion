1:application server and web server
2:spring annoation differences
@component @service @repositor @controller
3:hibernate 
differnce b/w session and entityManager interface
4::Hibernate: diff. among save, persist, update, merge, saveOrUpdate 
5:States of Entity Instances 
transient,persistent,detached
6:hibenrate diff. b/w eager and lazy fetching
7:role of hibernate.hbm.xml file
8:hibernate cache level , distrubuted cache 
9:spring bean life cycle
10:spring default controller in spring and internal working
11:spring XML Schema-based configuration dtd files info
12:hibernate mapping onetoone,onetomany,manytoone,manytomany
13:hibernate cache control working 
14::mapping
Hibernate working
SpringBeanFactory
Spring bean life cycle
DispatcherServlet(FrontController)
15::As you’ll see, DispatcherServlet is very extensible. For example, it allows you to plug in different existing or new adapters for a lot of tasks:
map a request to a class or method that should handle it (implementations of the HandlerMappinginterface)
handle a request using a specific pattern, like a regular servlet, a more complex MVC workflow, or just a method in a POJO bean (implementations of the HandlerAdapter interface)
resolve views by name, allowing you to use different templating engines, XML, XSLT or any other view technology (implementations of the ViewResolver interface)
parse multipart requests by using the default Apache Commons file uploading implementation or writing your own MultipartResolver
resolve locale with any LocaleResolver implementation, including cookie, session, Accept HTTP header, or any other way of determining the locale expected by the user
16::
What is difference between BeanFactory and ApplicationContext in Spring framework
17::
@Component – generic and can be used across application.
@Service – annotate classes at service layer level.
@Controller – annotate classes at presentation layers level, mainly used in Spring MVC.
@Repository – annotate classes at persistence layer, which will act as database repository.
@Repository annotation is a marker for any class that fulfills the role or stereotype (also known as Data Access Object or DAO)


@component-->controller(presentation)
	  --->service(service)	
	  --->repositor(persistent/Dao)	

@Component: It is a basic auto component scan annotation, it indicates annotated class is an auto scan component.

@Controller: Annotated class indicates that it is a controller component, and mainly used at the presentation layer.

@Service: It indicates annotated class is a Service component in the business layer.

@Repository: You need to use this annotation within the persistence layer, this acts like database repository.

@Services hold business logic and call method in repository layer.
18::
diff b/w restcontroller and controller
@restController ==>@Controler +@Response body

19::
transient — this instance is not, and never was, attached to a Session; this instance has no corresponding rows in the database; it’s usually just a new object that you have created to save to the database;
persistent — this instance is associated with a unique Session object; upon flushing the Session to the database, this entity is guaranteed to have a corresponding consistent record in the database;
detached — this instance was once attached to a Session (in a persistent state), but now it’s not; an instance enters this state if you evict it from the context, clear or close the Session, or put the instance through serialization/deserialization process.


save(),persit()
saveorupdate()
                       (sessoin)
new -->transient---->persitent----->detached(evict(),session.close())
	delete()<----	 ^    <----- lock(),update(),merge(),saveOrupdate()
			 |	
			get(),load()(hql query)
20::

hibernate persist::
Hibernate persist is similar to save (with transaction) and it adds the entity object to the persistent context, so any further changes are tracked. If the object properties are changed before the transaction is committed or session is flushed, it will also be saved into database.

Second difference is that we can use persist() method only within the boundary of a transaction, so it’s safe and takes care of any cascaded objects.

Hibernate saveOrUpdate::
Hibernate saveOrUpdate results into insert or update queries based on the provided data. If the data is present in the database, update query is executed.

We can use saveOrUpdate() without transaction also, but again you will face the issues with mapped objects not getting saved if session is not flushed.
Hibernate saveOrUpdate adds the entity object to persistent context and track any further changes. Any further changes are saved at the time of committing transaction, like persist.

Hibernate update::
Hibernate update should be used where we know that we are only updating the entity information. This operation adds the entity object to persistent context and further changes are tracked and saved when transaction is committed. Let’s check this behavior with a simple program

Hibernate Merge::
Hibernate merge can be used to update existing values, however this method create a copy from the passed entity object and return it. The returned object is part of persistent context and tracked for any changes, passed object is not tracked. This is the major difference with merge() from all other methods. Let’s look at this with a simple program.
21::
The difference between get and load methods lies in return value when the identifier does not exist in database.

In case of get() method, we will get return value as NULL if identifier is absent.
But in case of load() method, we will get a runtime exception.


Hibernate Merging and Refreshing Entities
refresh() and merge() ::
refresh::
These methods will reload the properties of the object from the database, overwriting them. In real life applications, you do not have to use the refresh() method very often apart from above stated scenario.

merge::
Method merge() does exactly opposite to what refresh() does i.e. It updates the database with values from a detached entity. Refresh method was updating the entity with latest database information. 
