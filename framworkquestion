1:application server and web server
2:spring annoation differences
@component @service @repositor @controller
3:hibernate 
differnce b/w session and entityManager interface
4::Hibernate: diff. among save, persist, update, merge, saveOrUpdate 
5:States of Entity Instances 
transient,persistent,detached
6:hibenrate diff. b/w eager and lazy fetching
7:role of hibernate.hbm.xml file
8:hibernate cache level , distrubuted cache 
9:spring bean life cycle
10:spring default controller in spring and internal working
11:spring XML Schema-based configuration dtd files info
12:hibernate mapping onetoone,onetomany,manytoone,manytomany
13:hibernate cache control working 
14::mapping
Hibernate working
SpringBeanFactory
Spring bean life cycle
DispatcherServlet(FrontController)
15::As you’ll see, DispatcherServlet is very extensible. For example, it allows you to plug in different existing or new adapters for a lot of tasks:
map a request to a class or method that should handle it (implementations of the HandlerMappinginterface)
handle a request using a specific pattern, like a regular servlet, a more complex MVC workflow, or just a method in a POJO bean (implementations of the HandlerAdapter interface)
resolve views by name, allowing you to use different templating engines, XML, XSLT or any other view technology (implementations of the ViewResolver interface)
parse multipart requests by using the default Apache Commons file uploading implementation or writing your own MultipartResolver
resolve locale with any LocaleResolver implementation, including cookie, session, Accept HTTP header, or any other way of determining the locale expected by the user
16::
What is difference between BeanFactory and ApplicationContext in Spring framework
17::
@Component – generic and can be used across application.
@Service – annotate classes at service layer level.
@Controller – annotate classes at presentation layers level, mainly used in Spring MVC.
@Repository – annotate classes at persistence layer, which will act as database repository.
@Repository annotation is a marker for any class that fulfills the role or stereotype (also known as Data Access Object or DAO)


@component-->controller(presentation)
	  --->service(service)	
	  --->repositor(persistent/Dao)	

@Component: It is a basic auto component scan annotation, it indicates annotated class is an auto scan component.

@Controller: Annotated class indicates that it is a controller component, and mainly used at the presentation layer.

@Service: It indicates annotated class is a Service component in the business layer.

@Repository: You need to use this annotation within the persistence layer, this acts like database repository.

@Services hold business logic and call method in repository layer.
18::
diff b/w restcontroller and controller
@restController ==>@Controler +@Response body


