java application
persistent object
hibernate properties xml mapping(configuration,session factory,sessiion,transaction,query,criteria)
JTA JDBC JNDi

database

data base configuration using hibernate.cfg.xml

class mapping setup 

Session Factory::
Configuration object is used to create a SessionFactory object which in turn configures Hibernate for the application using the supplied configuration file and allows for a Session object to be instantiated. The SessionFactory is a thread safe object and used by all the threads of an application.

The SessionFactory is a heavyweight object; it is usually created during application start up and kept for later use. 


Query Object ::uses sql or hibernate query language (HQL) 

Criteria Object::Criteria objects are used to create and execute object oriented criteria queries to retrieve objects.

hibernate.properties, or as an XML file named hibernate.cfg.xml.

<hibernate-configuration>
<property name= "hibernate.dialect"></property>
<property name="hibarnate.connection.driver_class">
com.mysql.jdbc.Driver
</property>


<!-- List of XML mapping files -->
      <mapping resource = "Employee.hbm.xml"/>
</>


A Session is used to get a physical connection with a database.
The session objects should not be kept open for a long time because they are not usually thread safe and they should be created and destroyed them as needed.

The main function of the Session is to offer, create, read, and delete operations for instances of mapped entity classes.


transient − A new instance of a persistent class, which is not associated with a Session and has no representation in the database and no identifier value is considered transient by Hibernate.

persistent − You can make a transient instance persistent by associating it with a Session. A persistent instance has a representation in the database, an identifier value and is associated with a Session.

detached − Once we close the Hibernate Session, the persistent instance will become a detached instance.

Transient instances may be made persistent by calling <tt>save()</tt>,
 * <tt>persist()</tt> or <tt>saveOrUpdate()</tt>. Persistent instances may be made transient
 * by calling<tt> delete()</tt>. Any instance returned by a <tt>get()</tt> or
 * <tt>load()</tt> method is persistent. Detached instances may be made persistent
 * by calling <tt>update()</tt>, <tt>saveOrUpdate()</tt>, <tt>lock()</tt> or <tt>replicate()</tt>. 
 * The state of a transient or detached instance may also be made persistent as a new
 * persistent instance by calling <tt>merge()</tt>.<br>

<i>transient:</i> never persistent, not associated with any <tt>Session</tt><br>
 * <i>persistent:</i> associated with a unique <tt>Session</tt><br>
 * <i>detached:</i> previously persistent, not associated with any <tt>Session</tt><br>


Session session=factory.openSession();
Transaction tx=null;
try{
Transaction tx=session.beginTransaction();
tx.commit();
}catch(Exception ex){
if(tx!=null) tx.rollback();
}finally{
session.close();
}



<tt>Criteria</tt> is a simplified API for retrieving entities
 * by composing <tt>Criterion</tt> objects. This is a very
 * convenient approach for functionality like "search" screens
 * where there is a variable number of conditions to be placed
 * upon the result set.<br>

 The <tt>Session</tt> is a factory for <tt>Criteria</tt>.
 * <tt>Criterion</tt> instances are usually obtained via
 * the factory methods on <tt>Restrictions</tt>. eg.

Criteria Cration::
session.crateCriteria(Cat.class).add(Restrictions.like("name","IZ%"))
.add(Restriction.get("weight",new Float(minweight)))
.addOrder(Order.asc("age"))
.list();



List cats=session.crateCriteria(Cat.class)
.add(Restriction.like('name','abc%'))
.add(Restriction.gt("wight",new Float(4)))
.addOrder(Order.asc("age"))
.list();

List cats=session.createCriteria(Cat.class)
.setProjection(Projection.projectionList)
.add(Projections.rowCount())
.add(Projections.max("weight"))
).addOrder(Order.asc("color"))
.list();

Restrictions










session.evict(Object obj)//remove instace from session cache 

session.flush()//Force this session to flush. Must be called at the end of a
	 * unit of work, before committing the transaction and closing the
	 * session (depending on {@link #setFlushMode(FlushMode)},


session.setCacheMode()//Cache mode determines the manner in which this session can interact with
	 * the second level cache.

//if isPutEnabled,isGetEnabled ==true  * The session may read items from the cache, and add items to the cache.

	IGNORE( false, false ),
* The session will never interact with the cache, except to invalidate
	 * cache items when updates occur.

CacheMode(boolean isPutEnabled,boolean isGetEnabled){
}

/**
	 * The session will never read items from the cache, but will add items
	 * to the cache as it reads them from the database.
	 */
	PUT( true, false ),


session.load(class,serializeid,lockmode)//Return the persistent instance of the given entity class with the given identifier,



LockMode


Persist the state of the given detached instance, reusing the current
	 * identifier value. 
replicate(Object object, ReplicationMode replicationMode)


 * Persist the given transient instance, first assigning a generated identifier. (Or
	 * using the current value of the identifier property if the <tt>assigned</tt>
	 * generator is used.) This operation cascades to associated instances if the
	 * association is mapped with {@code cascade="save-update"}

	Serializable save(Object object);



 * Copy the state of the given object onto the persistent object with the same
	 * identifier. If there is no persistent instance currently associated with
	 * the session, it will be loaded. Return the persistent instance. If the
	 * given instance is unsaved, save a copy of and return it as a newly persistent
	 * instance. The given instance does not become associated with the session.
	 * This operation cascades to associated instances if the association is mapped
	 * with {@code cascade="merge"}

Object merge(Object object);



* Make a transient instance persistent. This operation cascades to associated
	 * instances if the association is mapped with {@code cascade="persist"}

void persist(Object object);



 * Remove a persistent instance from the datastore. The argument may be
	 * an instance associated with the receiving <tt>Session</tt> or a transient
	 * instance with an identifier associated with existing persistent state.

void delete(Object object);



void refresh(Object object);

	 * Re-read the state of the given instance from the underlying database. It is
	 * inadvisable to use this to implement long-running sessions that span many




 * Return the persistent instance of the given entity class with the given identifier,
Object get(String entityName, Serializable id, LockMode lockMode);

All classes should contain an ID in order to allow easy identification of your objects within Hibernate and the database. This property maps to the primary key column of a database table.


crate table Employee(
id int not null auto_increment,
firstname varchar(33) default null,
lastname varchar(44) default null,
salry int default null,
primary key(id)
)

 Employee.hbm.xml.
<classname>.hbm.xml
<hibernate-mapping>
<class name="Employee" table="employee">
<meta attribute="class dessc">
</class>

<id name="id" type="int" column="id">
<genrator class="native"/>

</id>


<property name="first" column="first" type="string">
</hibernate-mapping>


The <id> element maps the unique ID attribute in class to the primary key of the database table. The name attribute of the id element refers to the property in the class and the column attribute refers to the column in the database table. The type attribute holds the hibernate mapping type, this mapping types will convert from Java to SQL data type.

The <generator> element within the id element is used to generate the primary key values automatically. The class attribute of the generator element is set to native to let hibernate pick up either identity, sequence, or hilo algorithm to create primary key depending upon the capabilities of the underlying database.


The <property> element is used to map a Java class property to a column in the database table. The name attribute of the element refers to the property in the class and the column attribute refers to the column in the database table. The type attribute holds the hibernate mapping type, this mapping types will convert from Java to SQL data type.


Primitive Types
Mapping type	Java type	ANSI SQL Type
integer	int or java.lang.Integer	INTEGER
long	long or java.lang.Long	BIGINT
short	short or java.lang.Short	SMALLINT
float	float or java.lang.Float	FLOAT
double	double or java.lang.Double	DOUBLE
big_decimal	java.math.BigDecimal	NUMERIC
character	java.lang.String	CHAR(1)
string	java.lang.String	VARCHAR
byte	byte or java.lang.Byte	TINYINT
boolean	boolean or java.lang.Boolean	BIT
yes/no	boolean or java.lang.Boolean	CHAR(1) ('Y' or 'N')
true/false	boolean or java.lang.Boolean	CHAR(1) ('T' or 'F')
Date and Time Types
Mapping type	Java type	ANSI SQL Type
date	java.util.Date or java.sql.Date	DATE
time	java.util.Date or java.sql.Time	TIME
timestamp	java.util.Date or java.sql.Timestamp	TIMESTAMP
calendar	java.util.Calendar	TIMESTAMP
calendar_date	java.util.Calendar	DATE
Binary and Large Object Types
Mapping type	Java type	ANSI SQL Type
binary	byte[]	VARBINARY (or BLOB)
text	java.lang.String	CLOB
serializable	any Java class that implements java.io.Serializable	VARBINARY (or BLOB)
clob	java.sql.Clob	CLOB
blob	java.sql.Blob	BLOB
JDK-related Types
Mapping type	Java type	ANSI SQL Type
class	java.lang.Class	VARCHAR
locale	java.util.Locale	VARCHAR
timezone	java.util.TimeZone	VARCHAR
currency	java.util.Currency	VARCHAR


 POJO (Plain Old Java Object) 

SessionFactory factory=new Configuration().configure("hibernate.cfg.xml").buildSessionFactory();


tx=session.beginTransaction();
List employees=session.createQuery("From Employee").list;


for(Iterator iterator=employee.iterator();iterator.hasnext();){
Employee emp=(Employee)iterator.next();
}
tx.commit();


mapping of collections;
mapping of assocation b/w entity class;
component mapping

Map,Set,SortedMap,SortedSet,List 


Association Mapping::
