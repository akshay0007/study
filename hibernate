java application
persistent object
hibernate properties xml mapping(configuration,session factory,sessiion,transaction,query,criteria)
JTA JDBC JNDi

database

data base configuration using hibernate.cfg.xml

class mapping setup 

Session Factory::
Configuration object is used to create a SessionFactory object which in turn configures Hibernate for the application using the supplied configuration file and allows for a Session object to be instantiated. The SessionFactory is a thread safe object and used by all the threads of an application.

The SessionFactory is a heavyweight object; it is usually created during application start up and kept for later use. 


Query Object ::uses sql or hibernate query language (HQL) 

Criteria Object::Criteria objects are used to create and execute object oriented criteria queries to retrieve objects.

hibernate.properties, or as an XML file named hibernate.cfg.xml.

<hibernate-configuration>
<property name= "hibernate.dialect"></property>
<property name="hibarnate.connection.driver_class">
com.mysql.jdbc.Driver
</property>


<!-- List of XML mapping files -->
      <mapping resource = "Employee.hbm.xml"/>
</>


A Session is used to get a physical connection with a database.
The session objects should not be kept open for a long time because they are not usually thread safe and they should be created and destroyed them as needed.

The main function of the Session is to offer, create, read, and delete operations for instances of mapped entity classes.


transient − A new instance of a persistent class, which is not associated with a Session and has no representation in the database and no identifier value is considered transient by Hibernate.

persistent − You can make a transient instance persistent by associating it with a Session. A persistent instance has a representation in the database, an identifier value and is associated with a Session.

detached − Once we close the Hibernate Session, the persistent instance will become a detached instance.

Transient instances may be made persistent by calling <tt>save()</tt>,
 * <tt>persist()</tt> or <tt>saveOrUpdate()</tt>. Persistent instances may be made transient
 * by calling<tt> delete()</tt>. Any instance returned by a <tt>get()</tt> or
 * <tt>load()</tt> method is persistent. Detached instances may be made persistent
 * by calling <tt>update()</tt>, <tt>saveOrUpdate()</tt>, <tt>lock()</tt> or <tt>replicate()</tt>. 
 * The state of a transient or detached instance may also be made persistent as a new
 * persistent instance by calling <tt>merge()</tt>.<br>

<i>transient:</i> never persistent, not associated with any <tt>Session</tt><br>
 * <i>persistent:</i> associated with a unique <tt>Session</tt><br>
 * <i>detached:</i> previously persistent, not associated with any <tt>Session</tt><br>


Session session=factory.openSession();
Transaction tx=null;
try{
Transaction tx=session.beginTransaction();
tx.commit();
}catch(Exception ex){
if(tx!=null) tx.rollback();
}finally{
session.close();
}



<tt>Criteria</tt> is a simplified API for retrieving entities
 * by composing <tt>Criterion</tt> objects. This is a very
 * convenient approach for functionality like "search" screens
 * where there is a variable number of conditions to be placed
 * upon the result set.<br>

 The <tt>Session</tt> is a factory for <tt>Criteria</tt>.
 * <tt>Criterion</tt> instances are usually obtained via
 * the factory methods on <tt>Restrictions</tt>. eg.

Criteria Cration::
session.crateCriteria(Cat.class).add(Restrictions.like("name","IZ%"))
.add(Restriction.get("weight",new Float(minweight)))
.addOrder(Order.asc("age"))
.list();



List cats=session.crateCriteria(Cat.class)
.add(Restriction.like('name','abc%'))
.add(Restriction.gt("wight",new Float(4)))
.addOrder(Order.asc("age"))
.list();

List cats=session.createCriteria(Cat.class)
.setProjection(Projection.projectionList)
.add(Projections.rowCount())
.add(Projections.max("weight"))
).addOrder(Order.asc("color"))
.list();

Restrictions










session.evict(Object obj)//remove instace from session cache 

session.flush()//Force this session to flush. Must be called at the end of a
	 * unit of work, before committing the transaction and closing the
	 * session (depending on {@link #setFlushMode(FlushMode)},


session.setCacheMode()//Cache mode determines the manner in which this session can interact with
	 * the second level cache.

//if isPutEnabled,isGetEnabled ==true  * The session may read items from the cache, and add items to the cache.

	IGNORE( false, false ),
* The session will never interact with the cache, except to invalidate
	 * cache items when updates occur.

CacheMode(boolean isPutEnabled,boolean isGetEnabled){
}

/**
	 * The session will never read items from the cache, but will add items
	 * to the cache as it reads them from the database.
	 */
	PUT( true, false ),


session.load(class,serializeid,lockmode)//Return the persistent instance of the given entity class with the given identifier,



LockMode


Persist the state of the given detached instance, reusing the current
	 * identifier value. 
replicate(Object object, ReplicationMode replicationMode)


 * Persist the given transient instance, first assigning a generated identifier. (Or
	 * using the current value of the identifier property if the <tt>assigned</tt>
	 * generator is used.) This operation cascades to associated instances if the
	 * association is mapped with {@code cascade="save-update"}

	Serializable save(Object object);



 * Copy the state of the given object onto the persistent object with the same
	 * identifier. If there is no persistent instance currently associated with
	 * the session, it will be loaded. Return the persistent instance. If the
	 * given instance is unsaved, save a copy of and return it as a newly persistent
	 * instance. The given instance does not become associated with the session.
	 * This operation cascades to associated instances if the association is mapped
	 * with {@code cascade="merge"}

Object merge(Object object);



* Make a transient instance persistent. This operation cascades to associated
	 * instances if the association is mapped with {@code cascade="persist"}

void persist(Object object);



 * Remove a persistent instance from the datastore. The argument may be
	 * an instance associated with the receiving <tt>Session</tt> or a transient
	 * instance with an identifier associated with existing persistent state.

void delete(Object object);



void refresh(Object object);

	 * Re-read the state of the given instance from the underlying database. It is
	 * inadvisable to use this to implement long-running sessions that span many




 * Return the persistent instance of the given entity class with the given identifier,
Object get(String entityName, Serializable id, LockMode lockMode);

All classes should contain an ID in order to allow easy identification of your objects within Hibernate and the database. This property maps to the primary key column of a database table.


crate table Employee(
id int not null auto_increment,
firstname varchar(33) default null,
lastname varchar(44) default null,
salry int default null,
primary key(id)
)

 Employee.hbm.xml.
<classname>.hbm.xml
<hibernate-mapping>
<class name="Employee" table="employee">
<meta attribute="class dessc">
</class>

<id name="id" type="int" column="id">
<genrator class="native"/>

</id>


<property name="first" column="first" type="string">
</hibernate-mapping>


The <id> element maps the unique ID attribute in class to the primary key of the database table. The name attribute of the id element refers to the property in the class and the column attribute refers to the column in the database table. The type attribute holds the hibernate mapping type, this mapping types will convert from Java to SQL data type.

The <generator> element within the id element is used to generate the primary key values automatically. The class attribute of the generator element is set to native to let hibernate pick up either identity, sequence, or hilo algorithm to create primary key depending upon the capabilities of the underlying database.


The <property> element is used to map a Java class property to a column in the database table. The name attribute of the element refers to the property in the class and the column attribute refers to the column in the database table. The type attribute holds the hibernate mapping type, this mapping types will convert from Java to SQL data type.


Primitive Types
Mapping type	Java type	ANSI SQL Type
integer	int or java.lang.Integer	INTEGER
long	long or java.lang.Long	BIGINT
short	short or java.lang.Short	SMALLINT
float	float or java.lang.Float	FLOAT
double	double or java.lang.Double	DOUBLE
big_decimal	java.math.BigDecimal	NUMERIC
character	java.lang.String	CHAR(1)
string	java.lang.String	VARCHAR
byte	byte or java.lang.Byte	TINYINT
boolean	boolean or java.lang.Boolean	BIT
yes/no	boolean or java.lang.Boolean	CHAR(1) ('Y' or 'N')
true/false	boolean or java.lang.Boolean	CHAR(1) ('T' or 'F')
Date and Time Types
Mapping type	Java type	ANSI SQL Type
date	java.util.Date or java.sql.Date	DATE
time	java.util.Date or java.sql.Time	TIME
timestamp	java.util.Date or java.sql.Timestamp	TIMESTAMP
calendar	java.util.Calendar	TIMESTAMP
calendar_date	java.util.Calendar	DATE
Binary and Large Object Types
Mapping type	Java type	ANSI SQL Type
binary	byte[]	VARBINARY (or BLOB)
text	java.lang.String	CLOB
serializable	any Java class that implements java.io.Serializable	VARBINARY (or BLOB)
clob	java.sql.Clob	CLOB
blob	java.sql.Blob	BLOB
JDK-related Types
Mapping type	Java type	ANSI SQL Type
class	java.lang.Class	VARCHAR
locale	java.util.Locale	VARCHAR
timezone	java.util.TimeZone	VARCHAR
currency	java.util.Currency	VARCHAR


 POJO (Plain Old Java Object) 

SessionFactory factory=new Configuration().configure("hibernate.cfg.xml").buildSessionFactory();


tx=session.beginTransaction();
List employees=session.createQuery("From Employee").list;


for(Iterator iterator=employee.iterator();iterator.hasnext();){
Employee emp=(Employee)iterator.next();
}
tx.commit();


mapping of collections;
mapping of assocation b/w entity class;
component mapping

Map,Set,SortedMap,SortedSet,List 

//////////////////////////////
Association Mapping::
Set mapping::

create table Employee(
id int  not null  auto increment,
first name varchar(33) default null,
last_name varchar(22) default null,
salary int default null,
primary key(id)
)

create table certificate(
id int not null auto increment,
certificate name varchar(33) default null,
employeeid int default null,
primary key(id)
)

public class Employee {
   private int id;
   private String firstName; 
   private String lastName;   
   private int salary;
   private Set certificates;
}


<hibernate-mapping>
<class name="Employee" table="employee">
<meta attribute="class description">
<id name="id" type="int" column="id">
<genrator class="native">
</id>

<set name="certificates" cascade="all">
<key column="employee_id">
<one-to-many class="certificate">
</set>

<list name="certificates" cascade="all">
<key column="employee_id"/>
<list-index column="idx"/>

//list 
<list> element is used to set the relationship between Certificate and Employee classes
<one-to-many class="certificate"/>
</list>

//collection
<bag name="cetificates" cascade="all">
<key column="employee_id"/>
<one-to-many class="certificate"/>
</bag>
 
<property name="firstname" column="firstname" type="string">
</meta>
</class>
</hibernate-mapping>


<map name="certificates" cascade="all">
<key column="employee_id"/>
<index column="certificate_type" type="string"/>
<one-to-many class="certificate"/>
</map>


The <bag> element is used to set the relationship between Certificate and Employee classes. We used the cascade attribute in the <bag> element to tell Hibernate to persist the Certificate objects at the same time as the Employee objects

The <generator> element within the id element is used to generate the primary key values automatically. The class attribute of the generator element is set to native to let hibernate pick up either identity, sequence or hilo algorithm to create primary key depending upon the capabilities of the underlying database.


The <set> element is new here and has been introduced to set the relationship between Certificate and Employee classes. We used the cascade attribute in the <set> element to tell Hibernate to persist the Certificate objects at the same time as the Employee objects. 


class ManageEmp{
public static void main(String arg[]){
try{

SessionFactory factory=new Configuration().configure("hibarnate.cfg").buildSessionFactory();

ManageEmployee me =new ManageEmployee();
HashSet set=new HashSet();
set.add(new Certificate("ff"))
set.add(new Certificate("ff"))

Integer empId=me.addEmployee("manog","kumar",set)


}catch(Exception ex){}
}


public Integer addEmployee(String fname,String lname,int salary,Set set){
Session session=factroy.openSession();

Transaction tx=session.beginTransaction();
session.save(emp);

List empl=session.createQuery("From Employee").list();
for(Iterator iterator=emp1;iteratro.hasNext();){
Employee emp=iterator.next();
tx.commit();
}

for(Iterator iterator1=)

}
}

class Certificate implements Comparable<Certificate>{

public in complareTo(Certificate cert){
int Before=-1;
int After=1;

if(cert==null){
return before}

Comparabel thisCertificate=this.getName();
Comparabel thatCertifciate=cert.getName();

if(thithisCertificatesCert==null){
return After}else (thatCertifciate==null){
retrunr before}else{
return this.certficate.compareTo(thatCertificate);
}
}
}



Association Mappings:::
1	Many-to-One
Mapping many-to-one relationship using Hibernate

2	One-to-One
Mapping one-to-one relationship using Hibernate

3	One-to-Many
Mapping one-to-many relationship using Hibernate

4	Many-to-Many
Mapping many-to-many relationship using Hibernate
'


Many to One::
crate table employee(
id int not null auto_increment,
firstname varchar(33) default null,
lasstname varchar(44) default null,
salary int default null,
address int not null,
primary key(id)
)

create table address(
id int not null auto_increment,
streetname varchar(44) default null,
cityname varchar(44) default null
statename varchar(454) default null,
zipcode varchar(33) default null
primary key(id)
)

class Employee{
int id;
String firstname;
String lastname;
private int salary;
private Address adddress;


}

public class Address{
int id
String street;
String city;
String state;
String zipcode;
}

<hibernate-mapping>
<meta attributes="class desc">the class contains des</meta>

<id name='id' type="int" column="id">
<genrate class="native">
<id>

<property naem ="firstname" column="firstname" type="string">

one-to-one::
A one-to-one association is similar to many-to-one association with a difference that the column will be set as unique. For example, an address object can be associated with a single employee object.

A One-to-Many::
 mapping can be implemented using a Set java collection that does not contain any duplicate element. We already have seen how to map Set collection in hibernate, so if you already learned Set mapping then you are all set to go with one-to-many mapping.


A many-to-one::
 association is the most common kind of association where an Object can be associated with multiple objects. For example, the same address object can be associated with multiple employee objects.


<many-to-one name="address" column="address">
classs="address" not-null="true">
</many-to-one>
</hibernate-mapping>

The <many-to-one> element is used to set the relationship between EMPLOYEE and ADDRESS entities. The name attribute is set to the defined variable in the parent class, in our case it is address. The column attribute is used to set the column name in the parent table EMPLOYEE.


<many-to-one name="address" column="address" unique="true" class="Address" not-null="true">
The <many-to-one> element is used to set the relationship between EMPLOYEE and ADDRESS entities. The name attribute is set to the defined variable in the parent class, in our case it is address. The column attribute is used to set the column name in the parent table EMPLOYEE, which is set to unique so that only one Employee object can be associated with an address object.


<may-to-many name="addres" column="address" class="Address" not-null=true>


new Configuration().configure().buildSessionFactory();
factory.openSession();
session.beginTransaction();
empid=session.save(emp,empid)
tx.commit()
if(tx!=null)
tx.rollback();
session.createQuery('from employee').list();
session.close()


many to many

<set name="certificates" cascade="save-update" table="EMP_CERT">
<key column='employee_id'/>
<many-to-many column="certificate-id" class='certificate'/>
</set>
The <set> element sets the relationship between Certificate and Employee classes. We set cascade attribute to save-update to tell Hibernate to persist the Certificate objects for SAVE i.e. CREATE and UPDATE operations at the same time as the Employee objects. The name attribute is set to the defined Set variable in the parent class, in our case it is certificates. For each set variable, we need to define a separate set element in the mapping file. Here we used name attribute to set the intermediate table name to EMP_CERT.


Hibernate - Component Mappings
A Component mapping is a mapping for a class having a reference to another class as a member variable. We have seen such mapping while having two tables and using <set> element in the mapping file. Now we will use <component> element in the mapping file and a single table would be used to keep the attributes contained inside the class variable.

The <component> element sets the existence of different attributes of Address class inside Employee classes.


<component name="address" class="Address">
<property name="firstname" column="firstname" type="string">
<property name="lastname" column="lastname" type="string">

<component>

hibernate annoation::
@Entity
@Table
class Employee{

@Id
@GenratedValue(value="")
@Column(name="salary")
int id;
}



@Entity Annotation

@Table Annotation

@Id and @GeneratedValue Annotations  @GeneratedValue annotation, which takes two parameters strategy and generator that 

@Column Annotation


factory=new AnnoationConfiguration().configure().addAnnoatedClass(abc.class).buildSessionFactory();

hql query::
from empliyee e where e.id>10 order by e.salary desc

hql=Delete from employee where id=:employeeid
qurey=session.cerateQuery(hql);
qurey.setParameter("empid",employeeid);


Criteria cr=session.createCriteria(Employye.class);
cr.add(Restrictions.eq("salary",100));
List result=cr.list();

Criterion salary=Restriction.gt("salary",2000)
Criterion name=Restriction.gt("name",2000)
LogicalExpression exor=Restriction.or(salary,name);
cr.add(exor)
LogicalExpression exand=Restriction.and(salary,name);
cr.add(exand)



The Criteria API provides the org.hibernate.criterion.Projections class, which can be used to get average, maximum, or minimum of the property values. The Projections class is similar to the Restrictions class, in that it provides several static factory methods for obtaining Projection instances.


String sql="select * from employeee"
SqlQuery query=session.createSqlQuery(sql)
query.addEntity(Employee.class)
query.setParameter("employee_id",10);



Caching is important to Hibernate as well. It utilizes a multilevel caching scheme as explained below −
database
firstlevelcache sessoin object
second level cache


First-level Cache
The first-level cache is the Session cache and is a mandatory cache through which all requests must pass. The Session object keeps an object under its own power before committing it to the database.

Second-level Cache
Second level cache is an optional cache and first-level cache will always be consulted before any attempt is made to locate an object in the second-level cache. The second level cache can be configured on a per-class and per-collection basis and mainly responsible for caching objects across sessions.


Query-level Cache
Hibernate also implements a cache for query resultsets that integrates closely with the second-level cache.


A concurrency strategy is a mediator, which is responsible for storing items of data in the cache and retrieving them from the cache. If you are going to enable a second-level cache, you will have to decide, for each persistent class and collection, which cache concurrency strategy to use


Transactional − Use this strategy for read-mostly data where it is critical to prevent stale data in concurrent transactions, in the rare case of an update.

Read-write − Again use this strategy for read-mostly data where it is critical to prevent stale data in concurrent transactions, in the rare case of an update.

Nonstrict-read-write − This strategy makes no guarantee of consistency between the cache and the database. Use this strategy if data hardly ever changes and a small likelihood of stale data is not of critical concern.

Read-only − A concurrency strategy suitable for data, which never changes. Use it for reference data only.



 batch processing 


Session session = SessionFactory.openSession();
Transaction tx = session.beginTransaction();
for ( int i=0; i<100000; i++ ) {
   Employee employee = new Employee(.....);
   session.save(employee);
   if( i % 50 == 0 ) { // Same as the JDBC batch size
      //flush a batch of inserts and release memory:
      session.flush();
      session.clear();
   }
}
tx.commit();
session.close();

ScrollableResults empcursor=session.crateQuery().scroll();

whilr(empcursor.next()){

}

<mapping resource = "Employee.hbm.xml"/>

