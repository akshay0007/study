suppose we have cource review student and passwport table

cource(id ,name) 
review (id,rating,description,courseid)    


 or is courseid is review id


class Course{
@OneToMany(mappedBy="course",fetch=FetctType.EaGER)//bcoz review is owing side
List<Review > data;
}

class Review{
@ManyToOne
private Course course;
}



manytomany
course:: id,name
student:: id name passportid


student_course::stu_id course_id


Course{

@ManyToMany()
List<Student>
}

Student{
@Manytomany
List<Course> courses
}

in thatt cse two join column created course_studnetn,studnet_course

Course{

@ManyToMany(mappedby="courses")
List<Student>
}


Student{
@Manytomany(fetch=FetchStratg.EAGER)
List<Course> courses
}






in lazy initalize

@Transactonal
public void retireForCourse(){
course.getReviews();//again hit for data base but due to lazy geting lazy initalize so used @Transactonal now it getting persist
}



course have multiple student and vice versa::

Course Student passport Review::


Course{id,name}
Student {id,name} 
passport{id,number}
Review{id,rating,description}

course and student manytomany
student and passport onetoone
course and review onetomany vice versa manytoone



student and passport one to one cretae either stu_id or passprot_id

student id,name,passport_id

class Student{
@Onetoone
Passport passport;//owining side of relationship
}


class Review{

}


public void savestudandpassport(){
Passport pass=new Passport('433');
em.persist(pass)//if we are not writing this line it through passport is not persist
Student stu=new Student;
stu.setPassport(pass)
em.persist(sti)
}



eager fatching::
onetoone manytoone is by default eager fatching:

Lazy fetching::
@OnetoOne(fetch=FetchType.Lazy)

lazy initailzation exc could not inintalize proxy  ::no session





em.perssit()//create hibernate sequence and assign value into id


Transaction entity mananager and persistent context
either all things are succed or nothing succed rollback

persistent context for each beans in block of methods



in @Trascation block persistent context create for this block and execute each query at the end of block


/////////////
OneToOne bydirectional mapping:::

Class {
OnetoOne
Passport passport;
}

class Passport{
@onetoOne
Student stu
}

both table create new entries student_id,passport_id

so used owing side of relationship properties

student to create owing side of relationship

class Passport{//non owing side
@OnetoOne(mappedby="passp")
Student stu
}

class Student{//owing side 
@OnetoOne
Passport passp
}


@Transactional
void somethig(){

//create object
em.persist(user1);//assign user to id but not save to db
em.persist(user2);// ""

//update
change user1//now update into user1
change user2//"" to user2



}//all chages down to the db saves


@Transactional
void somethig(){

//create object
em.persist(user1);//assign user to id but not save to db
em.persist(user2);// ""

em.flush()//changes push down into db

//update
change user1//if there is problems it rollback from init
change user2//"" to user2



}//all chages down to the db saves


why u need transactonal :::
Repository=>EntittyManager
UnitTesting=>EntiityManager

entire logic within boundries is transactional

update in any block or changes by using entitymangaer directly we need tranasactional


///////////////////////////////////////////
Class Student{
@manytomany
@JoinTable(name="student_course",
joinColumn=@JoinColumn(name="student_id"),
inversejoinColumn=@JoinColumn(name="course_id"))
List<Course> course;
}

class Course{

@ManytoMany(mappedBy="course")
List<Student> students
}



/////////////////////////////////////////
faq3

User user=em.find(USer.class,1)


List<Comment> comment=user.getComments();//if we are not write transacton in this block data base connection is not established
so require transacton

return comments

@Test
@DirectiesContext
inside block on testing method if all updates happens database 
roll back
 

fetchStrategy=Strategy.Eager

call next value of hibernate sequence(id ===some value)

inheritance::
Tables::Employee ,FullTimeEmployee,PartTimeEmployee

types of inheritance::
singel table,tableperclasss,joined.mappedSuperClass


@Entity
@Inheritance(strategy=InheritanceTYpe.Single_Table)




IheritanceType{Single_table,Table_per_class,Joined}

Transaction Management::
200 300 deduct from a account
150 300 
150 350 deposit 50 from b account


ACID properties:::
A::atomicity==>either trans. should be comp succesff or all trans revert back
C::concurrent==>it should not matter how many tras running in parellel ,but end state of trans. should be same.either they are running in parellel or sequentially
I::isolation==>multiple level of isolation one trans effect another trans. if thery are running in parellel.suppose A doing some trans. then update value of A is provided to B or not
D::durablity==>if trans. running and due to system crash or something wrong happend end state of transaction should be persistent.


transactin ::A$50 to b and trans2 A$100 to C
Dirty read::read the value of transaction by another transaction before commiting tranansaction
non repetable read::when i am reading same values 2ys getting 2 different values
phantom read::at different time i am getting different rows in the same transacton.


		dirty read  non repetable phantom read
Read uncommited ::possible  ::possible  ::possible   lock on trans value
read commited   ::solve     ::possible  ::possible   lock on rows 
repeatable read ::solve     ::solve     ::possible   lock the row until trans complete then run another trans on sm row
serializable    ::solve     ::solve     ::solve      lock would be created on constraint applied on table then it create lock ,no delete update and insert perform on constraint after this opration perform



@Transactional(jax,spring)
if u are using two database changes then used spring tranasactional
if u are using one database changes then used javax tranasactional
//database1
//database2

@Transactoinal(isolation="")

//isolation level	
hibarnate.connection.isolation=2



Generated with SEQUENCE strategy
And if you use the SEQUENCE, Hibernate performs an SQL SELECT statement to retrieve the next value from the database sequence. Hibernate then delays the INSERT statement until it flushes the persistence context. In this example, the flush happens when the transaction gets committed.


14:10:27,994  INFO TestPersistSaveMerge:237 - Save entity
14:10:28,002 DEBUG SQL:92 - 
    select
        nextval ('hibernate_sequence')
14:10:28,042  INFO TestPersistSaveMerge:240 - Commit transaction
14:10:28,096 DEBUG SQL:92 - 
    insert
    into
        Author
        (firstName, lastName, version, id) 
    values
        (?, ?, ?, ?)


Generated with TABLE strategy
You shouldn’t use the TABLE strategy because it requires row level locks on the primary key table and doesn’t scale well. If you use this strategy anyways, Hibernate performs an SQL SELECT statement to retrieve the next primary key value from the database and writes the new value to the database table. It delays the execution of the SQL INSERT statement for the new entity until it flushes the persistence context.

14:11:17,368  INFO TestPersistSaveMerge:237 - Save entity
14:11:17,482 DEBUG SQL:92 - 
    select
        tbl.next_val 
    from
        hibernate_sequences tbl 
    where
        tbl.sequence_name=? for update
            of tbl
14:11:17,531 DEBUG SQL:92 - 
    insert
    into
        hibernate_sequences
        (sequence_name, next_val)  
    values
        (?,?)
14:11:17,534 DEBUG SQL:92 - 
    update
        hibernate_sequences 
    set
        next_val=?  
    where
        next_val=? 
        and sequence_name=?
14:11:17,584  INFO TestPersistSaveMerge:240 - Commit transaction
14:11:17,655 DEBUG SQL:92 - 
    insert
    into
        Author
        (firstName, lastName, version, id) 
    values
        (?, ?, ?, ?)


 

How do you get the primary key values in your application? Do you use natural keys or do you generate technical IDs?

Don’t want to read? You can watch it here!

Watch this video on YouTube
Follow me on YouTube to not miss any new videos.

I prefer to generate simple, numerical, technical IDs like you can see in the following code snippet instead of using natural keys which often require the combination of multiple attributes.

@Id
@Column(name = "id", updatable = false, nullable = false)
private Long id;
view rawPrimaryKey.java hosted with ❤ by GitHub
Technical IDs are easier to manage and all involved systems, mainly the database and Hibernate, can index them very efficiently. This allows you to focus on the business logic of your application and avoids performance issues.  
 

4 options to generate primary keys
The JPA specification supports 4 different primary key generation strategies which generate the primary key values programmatically or use database features, like auto-incremented columns or sequences. The only thing you have to do is to add the @GeneratedValue annotation to your primary key attribute and choose a generation strategy.
@Id
@GeneratedValue
@Column(name = "id", updatable = false, nullable = false)
private Long id;
view rawGeneratedValue.java hosted with ❤ by GitHub


Join the Thoughts on Java Library

Get free access to:

2 Ebooks about JPA and Hibernate
More than 50 Cheat Sheets
More than 60 printable Hibernate Tips
A 3-Part Video Course about Finding and Fixing N+1 Select Issues
Signup For Free:


Email

Password

Password Confirmation
JOIN NOW!

Already a member? Login here.


 
GenerationType.AUTO
The GenerationType.AUTO is the default generation type and lets the persistence provider choose the generation strategy.

@Id
@GeneratedValue(strategy = GenerationType.AUTO)
@Column(name = "id", updatable = false, nullable = false)
private Long id;
view rawGenerationTypeAuto.java hosted with ❤ by GitHub
If you use Hibernate as your persistence provider, it selects a generation strategy based on the database specific dialect. For most popular databases, it selects GenerationType.SEQUENCE which I will explain later.  

 

Watch it on YouTube

Watch this video on YouTube
Follow me on YouTube to not miss any new videos.
GenerationType.IDENTITY
The GenerationType.IDENTITY is the easiest to use but not the best one from a performance point of view. It relies on an auto-incremented database column and lets the database generate a new value with each insert operation. From a database point of view, this is very efficient because the auto-increment columns are highly optimized, and it doesn’t require any additional statements.

@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
@Column(name = "id", updatable = false, nullable = false)
private Long id;
view rawGenerationTypeIdentity.java hosted with ❤ by GitHub
This approach has a significant drawback if you use Hibernate. Hibernate requires a primary key value for each managed entity and therefore has to perform the insert statement immediately. This prevents it from using different optimization techniques like JDBC batching.

 

Watch it on YouTube

Watch this video on YouTube
Follow me on YouTube to not miss any new videos.
GenerationType.SEQUENCE
The GenerationType.SEQUENCE is my preferred way to generate primary key values and uses a database sequence to generate unique values.

It requires additional select statements to get the next value from a database sequence. But this has no performance impact for most applications. And if your application has to persist a huge number of new entities, you can use some Hibernate specific optimizations to reduce the number of statements.

@Id
@GeneratedValue(strategy = GenerationType.SEQUENCE)
@Column(name = "id", updatable = false, nullable = false)
private Long id;
view rawGenerationTypeSequence.java hosted with ❤ by GitHub
If you don’t provide any additional information, Hibernate will request the next value from its default sequence. You can change that by referencing the name of a @SequenceGenerator in the generator attribute of the @GeneratedValue annotation. The @SequenceGenerator annotation lets you define the name of the generator, the name, and schema of the database sequence and the allocation size of the sequence.

@Id
@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "book_generator")
@SequenceGenerator(name="book_generator", sequenceName = "book_seq", allocationSize=50)
@Column(name = "id", updatable = false, nullable = false)
private Long id;
view rawSequenceGenerator.java hosted with ❤ by GitHub
 

GenerationType.TABLE
The GenerationType.TABLE gets only rarely used nowadays. It simulates a sequence by storing and updating its current value in a database table which requires the use of pessimistic locks which put all transactions into a sequential order. This slows down your application, and you should, therefore, prefer the GenerationType.SEQUENCE, if your database supports sequences, which most popular databases do.

@Id
@GeneratedValue(strategy = GenerationType.TABLE)
@Column(name = "id", updatable = false, nullable = false)
private Long id;
view rawGenerationTypeTable.java hosted with ❤ by GitHub
You can use the @TableGenerator annotation in a similar way as the already explained @SequenceGenerator annotation to specify the database table which Hibernate shall use to simulate the sequence.

@Id
@GeneratedValue(strategy = GenerationType.TABLE, generator = "book_generator")
@TableGenerator(name="book_generator", table="id_generator", schema="bookstore")
@Column(name = "id", updatable = false, nullable = false)
private Long id;


hibernate merge and update::
You can use Hibernate’s update or JPA’s merge method to associate a detached entity with a persistence context. After you’ve done that, Hibernate will update the database based on the entity attribute values.

ui web-->service-->data-->database

in data caching machanism apply..


hibenate two level canche::
firslevel
and second level
Persistence context-->FirstlevelCache-->Second level cache-->Database




t1  t2 t3 running in parellel
||
PersistenceContext pc1
PersistenceContext pc2
PersistenceContext pc3
||

second level cache
||
database


first time go to db ret data and placed into persitent context::
then all commn happend from persistenc context(first level cache)


across multiple transsaction and multiple user use it::
list of countries and stats cannot change for same countries
we can stored this data into second level cache..



first level cache for single transacton..

second level cache which is common across the user..




First level cache::

@Transactional
public void findById(){
repository.findById(1000l);


repository.findById(1001l);

boundry of transaction two different transactoin hit db for retrieveing data 


Second level cache configuration::
manually done.
ehcache ,redis etc..

enable second level cache
spring.jpa.properties.hibernate.cache.use_second_level_cache=true
specifing the caching freamwor::EhCache
(EhcacheRegionFactory class)
spring.jpa.properties.hibernate.cache.region,factoryclass=EhcacheRegionFactory
only cache what i tell to cache
(sharedCacheMode enum)
spring.jpa.properties.javax.persistence.sharedCacheMode=Enable_selective
logging.level.net.sf.ehcache=debug
what data to cache?


@Cacheable

L2C puts(level to cache)

L2C hits

L2C miss

hits::when looking into cache it find out
miss::not found into cache


performance tuning::


turn statics on
spring.jpa.properties.hibernate.genrate_statics=true
loggin.level.org.hibernate.stat=debug


Indexes::
good indexes.
execution plan


use appropriate caching::
first level caching::within single trans
second level caching::enable it by using second level cache diff tras on the same server same instance of app share same data
like courtries,states
distributed cache::u are running lots of appliation in pareellel then distrbute one app not suff. dist. load multiple application instance 
caching in mulitple application like hazelcast
be careful about size of first level cache.


Eager vs Lazy::
mostly lazy fetching

suffix with one is alwys eager fetch

Avoid N+1 problem::

for finding values we run one query and supporting 3 query run
for 1000 of queries 3*1000 queries

solvingn+1proble(){
EntityGraph<Course> entityGraph=em.createEntityGraph(Course.class)
SubGraph<Object> subgraph=entityGraph.addSubgraph("student");
em.createNameQuery("queery",Course.class)
.setHint("javax.persistence.loadgreaph",entityGraph)
.getResultList();
}


solvingn+1probleJoinFetch(){



}
